# Course Work ( COMP311 )

### [Lab 2](https://github.com/hollyjrobertson/COMP311/tree/master/Lab2 "Lab 2")
  #### Purpose:   
  * Focus on the tree structures, recursion, and the [Visitor](https://www.tutorialspoint.com/design_pattern/visitor_pattern.htm "Visitor"), [Strategy](https://www.tutorialspoint.com/design_pattern/strategy_pattern.html "Strategy") and   
  
   ### [HW1](https://github.com/hollyjrobertson/COMP311/tree/master/hw1 "HW1")
 
 ### [HW2](https://github.com/hollyjrobertson/COMP311/tree/master/hw2 "HW2")
 
  ### [HW3](https://github.com/hollyjrobertson/COMP311/tree/master/hw3 "HW3")

 
### [HW4](https://github.com/hollyjrobertson/COMP311/tree/master/hw4 "HW4")
  
 ### [HW5](https://github.com/hollyjrobertson/COMP311/blob/master/RobertsonHolly_HW5.pdf "HW5")
  #### Problem 1:
  A k-way heap is like a binary heap except that instead of at most two child nodes, internal nodes 
  may have up to k children. Just like with binary heaps, k-way heaps can be efficiently kept in an array.  
  * Provide two formulas for this mapping along with a written explanation and an example of the  
    mapping. The formulas are: parentOf(j) and ithChildOf(i, j) where j represents a node number   
    and i is a child number within a node {0, 1, 2, … k-1}.  
  * Comment on how this will affect the space and time complexity of the operations.  
  
  ###Problem 2:  
  Draw the binary heap that results from this series of inserts into an initially empty heap:    
  Insert 10, 12, 1, 14, 6, 5, 8, 15.  Show the result of performing two DeleteMin operations on the  
  resulting heap.  Show, separately, the result of each individual insert/delete.
  
  ### [HW8](https://github.com/hollyjrobertson/COMP311/tree/master/hw8.pdf "HW8")
  #### Problem 1:
  Diagram and explain an adjacency matrix and it's time complexity, and indirect/direct graphs.  
  ![image](https://user-images.githubusercontent.com/31171295/129286154-df69e4be-66e6-4273-95a7-68cae3301151.png)

  ### [HW9](https://github.com/hollyjrobertson/COMP311/tree/master/hw9.pdf "HW9")
  #### Problem 1:  
  Apply Dijkstra’s algorithm to the graph below starting from vertex A.  Show the predecessor and distance arrays after each pass of the algorithm.

  #### Problem 2:
  Apply Prim’s algorithm to the graph below starting from vertex 1.  Show the spanning tree after each edge is added.  
  
  ### [HW10](https://github.com/hollyjrobertson/COMP311/tree/master/hw10.pdf "HW10")
  #### Problem 1:  
  Consider an AVL tree whose root has a height of 5. What is the maximum difference between the depths of any two leaves in this tree. Briefly justify your answer.
  ```
  If the difference between any two leaves is greater than 1, it isn’t a balanced AVL tree. It needs to be rotated to fit 
  the structure of an AVL tree. 
  ```
  #### Problem 2:
  Starting with an empty AVL tree, insert the following keys in the order given: 0, 17, 6, 4, 5, 10, 15, 13, 12, 11. Show the AVL tree after each insertion 
  
